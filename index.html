<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CryptoDash Pro ‚Äî Coin Detail (CoinCap)</title>
<link rel="icon" href="data:," />
<style>
  :root{
    --bg:#071026; --panel:#07182a; --muted:#98a4b2; --accent:#00d1b2; --danger:#ff6b6b;
    --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#021021);color:#e6eef6}
  .wrap{max-width:1200px;margin:18px auto;padding:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#60a5fa);display:flex;align-items:center;justify-content:center;font-weight:700;color:#042}
  .controls{display:flex;gap:8px;align-items:center}
  input,select,button{padding:8px 12px;border-radius:10px;border:0;background:var(--panel);color:inherit}
  main{margin-top:16px}
  .card{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;text-align:left}
  thead th{color:var(--muted);font-size:12px}
  .muted{color:var(--muted)}
  .spark{width:120px;height:36px}
  .pill{display:inline-block;padding:6px 8px;border-radius:999px;background:var(--glass);cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:16px}
  @media (max-width:980px){.grid{grid-template-columns:1fr} .logo{display:none}}
  #tvchart{height:520px;width:100%}
  .range-buttons{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
  .range-buttons button.active{outline:2px solid rgba(0,209,178,0.14)}
  .indicator-toggle{display:flex;gap:12px;align-items:center;margin-bottom:8px}
  .stat{display:flex;justify-content:space-between}
  .links a{display:inline-block;margin-right:8px;color:var(--accent)}
  .empty{padding:40px;text-align:center;color:var(--muted)}
  footer{margin-top:16px;color:var(--muted);font-size:13px}
  .small{font-size:12px;color:var(--muted)}
</style>

<!-- Lightweight Charts for candlestick -->
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
<!-- Chart.js for tiny sparklines -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">CD</div>
        <div>
          <div style="font-weight:700;font-size:18px">CryptoDash Pro</div>
          <div class="muted small">Beautiful market explorer ‚Äî data: CoinCap</div>
        </div>
      </div>

      <div class="controls">
        <input id="search" placeholder="Cari koin atau symbol (bitcoin, ethereum)" />
        <select id="currency"><option value="usd">USD</option></select>
        <button id="themeBtn">üåô</button>
      </div>
    </header>

    <main id="appMain">
      <!-- LIST PAGE -->
      <section id="listPage">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div><strong id="statsCount">‚Äî</strong> <span class="muted">coins</span></div>
            <div class="muted">Watchlist: <span id="favCount">0</span></div>
          </div>

          <div style="overflow:auto">
            <table>
              <thead>
                <tr><th>#</th><th>Name</th><th>Price (USD)</th><th>24h %</th><th>Market Cap</th><th>Spark</th><th>Actions</th></tr>
              </thead>
              <tbody id="coinsTbody"></tbody>
            </table>
          </div>
        </div>
      </section>

      <!-- DETAIL PAGE -->
      <section id="detailPage" style="display:none">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
          <div style="display:flex;gap:12px;align-items:center">
            <button id="backBtn" class="pill">‚Üê Back</button>
            <h2 id="coinTitle">Coin</h2>
          </div>
          <div class="muted" id="priceNow">‚Äî</div>
        </div>

        <div class="grid">
          <div class="card">
            <div class="range-buttons" role="tablist" aria-label="Range">
              <button data-days="1" class="rangeBtn">1D</button>
              <button data-days="7" class="rangeBtn">7D</button>
              <button data-days="30" class="rangeBtn active">30D</button>
              <button data-days="90" class="rangeBtn">90D</button>
              <button data-days="365" class="rangeBtn">1Y</button>
            </div>

            <div class="indicator-toggle">
              <label><input type="checkbox" id="smaToggle"/> SMA</label>
              <label><input type="checkbox" id="emaToggle"/> EMA</label>
              <div class="small muted">Indicators apply on current chart.</div>
            </div>

            <div id="tvchart" class="card" style="margin-top:8px;padding:8px"></div>
            <div id="chartNote" class="muted small" style="margin-top:8px">Candlestick chart ‚Äî data source: CoinCap (converted to OHLC where necessary)</div>
          </div>

          <aside class="card">
            <div style="display:flex;flex-direction:column;gap:12px">
              <div>
                <strong>About</strong>
                <div id="coinDesc" class="muted small" style="margin-top:6px;max-height:160px;overflow:auto">Description not provided by CoinCap ‚Äî use external source if needed.</div>
              </div>

              <div>
                <strong>Stats</strong>
                <div class="muted small" style="margin-top:6px">
                  <div class="stat"><span>Rank</span><span id="coinRank">‚Äî</span></div>
                  <div class="stat"><span>Market Cap</span><span id="coinMarketCap">‚Äî</span></div>
                  <div class="stat"><span>24h Volume</span><span id="coinVolume">‚Äî</span></div>
                  <div class="stat"><span>Supply</span><span id="coinSupply">‚Äî</span></div>
                  <div class="stat"><span>Price (USD)</span><span id="coinPrice">‚Äî</span></div>
                </div>
              </div>

              <div>
                <strong>Links</strong>
                <div id="coinLinks" class="muted small" style="margin-top:6px">‚Äî</div>
              </div>

              <div style="display:flex;gap:8px;margin-top:8px">
                <button id="favBtn" class="pill">‚òÜ Add to Watchlist</button>
                <button id="shareBtn" class="pill">Share</button>
              </div>
            </div>
          </aside>
        </div>
      </section>
    </main>

    <footer class="muted">Built with CoinCap API ‚Ä¢ Drop into GitHub Pages as index.html</footer>
  </div>

<script>
/* -------- CONFIG & STATE -------- */
const API_BASE = 'https://api.coincap.io/v2'
const state = {
  coins: [],
  favorites: new Set(JSON.parse(localStorage.getItem('cd:cap:favs')||'[]')),
  current: null,
  lastChartRaw: null, // store raw price points used to create chart (for indicators)
}

/* -------- HELPERS -------- */
const $ = sel => document.querySelector(sel)
function fmt(n){ if(n===null||n===undefined) return '‚Äî'; const num = Number(n); if(isNaN(num)) return n; if(Math.abs(num)>1e12) return (num/1e12).toFixed(2)+'T'; if(Math.abs(num)>1e9) return (num/1e9).toFixed(2)+'B'; if(Math.abs(num)>1e6) return (num/1e6).toFixed(2)+'M'; if(Math.abs(num)>1e3) return (num/1e3).toFixed(2)+'k'; return num.toLocaleString() }
function safeFetch(url){ return fetch(url).then(r=>{ if(!r.ok) throw new Error(r.status+' '+r.statusText); return r.json() }) }

/* -------- API WRAPPERS (CoinCap) -------- */
async function fetchMarkets(limit=100){
  const url = `${API_BASE}/assets?limit=${limit}`
  return safeFetch(url).then(d=>d.data)
}
async function fetchAsset(id){
  // id in CoinCap is e.g. bitcoin, ethereum
  const url = `${API_BASE}/assets/${id}`
  return safeFetch(url).then(d=>d.data)
}
async function fetchHistory(id, interval, start, end){
  // interval: m1,h1,d1 ; start/end in ms
  const url = `${API_BASE}/assets/${id}/history?interval=${interval}&start=${start}&end=${end}`
  return safeFetch(url).then(d=>d.data) // returns array of { price, time }
}

/* -------- LIST PAGE -------- */
async function loadMarket(){
  try{
    $('#coinsTbody').innerHTML = '<tr><td colspan="7" class="muted">Loading‚Ä¶</td></tr>'
    const list = await fetchMarkets(200)
    // sort by rank ascending
    list.sort((a,b)=> Number(a.rank) - Number(b.rank))
    state.coins = list
    renderList(list)
    $('#statsCount').textContent = list.length
    $('#favCount').textContent = state.favorites.size
  }catch(e){
    console.error(e)
    $('#coinsTbody').innerHTML = `<tr><td colspan="7" class="muted">Gagal memuat pasar: ${e.message}</td></tr>`
  }
}

function renderList(list){
  const tbody = $('#coinsTbody'); tbody.innerHTML = ''
  list.forEach((c,i)=>{
    const tr = document.createElement('tr')
    const pct = c.changePercent24Hr ? Number(c.changePercent24Hr) : null
    tr.innerHTML = `
      <td style="width:48px">${c.rank ?? (i+1)}</td>
      <td style="min-width:220px"><strong>${c.name}</strong> <div class="muted small">${c.symbol}</div></td>
      <td>${Number(c.priceUsd).toFixed(6)}</td>
      <td style="color:${pct>=0? '#4ade80':'#ff8383'}">${pct!==null? pct.toFixed(2)+'%':'‚Äî'}</td>
      <td class="muted">${fmt(c.marketCapUsd)}</td>
      <td><canvas class="spark" data-idx="${i}" width="120" height="36"></canvas></td>
      <td><button class="pill fav" data-id="${c.id}">${state.favorites.has(c.id)?'‚òÖ':'‚òÜ'}</button> <button class="pill" data-id="${c.id}" data-action="open">Detail</button></td>
    `
    tbody.appendChild(tr)
  })
  // attach listeners
  document.querySelectorAll('.pill[data-action="open"]').forEach(b=>b.onclick = e => {
    const id = e.target.dataset.id
    location.hash = '#/coin/' + id
  })
  document.querySelectorAll('.fav').forEach(b=>b.onclick = toggleFav)
  // draw tiny sparklines: for speed, we use recent price from state (CoinCap does not include sparkline, so approximate using history fetch per coin is heavy).
  // Instead, we'll draw a placeholder flat sparkline (cheap) and fetch actual history when user opens detail.
  document.querySelectorAll('.spark').forEach(cv => {
    const ctx = cv.getContext('2d')
    // simple decorative line
    new Chart(ctx, {
      type:'line',
      data:{ labels: new Array(20).fill('').map((_,i)=>i), datasets:[{ data: new Array(20).fill(0).map(()=>Math.random()*1.2), borderWidth:1, pointRadius:0 }]},
      options:{ animation:false, plugins:{legend:{display:false}}, scales:{x:{display:false},y:{display:false}}}
    })
  })
}

/* -------- FAVORITES -------- */
function toggleFav(e){
  const id = e.target.dataset.id
  if(!id) return
  if(state.favorites.has(id)) state.favorites.delete(id)
  else state.favorites.add(id)
  localStorage.setItem('cd:cap:favs', JSON.stringify([...state.favorites]))
  // update UI
  document.querySelectorAll(`.fav[data-id="${id}"]`).forEach(btn => btn.textContent = state.favorites.has(id)? '‚òÖ' : '‚òÜ')
  $('#favCount').textContent = state.favorites.size
}

/* -------- ROUTING: simple hash router -------- */
window.addEventListener('hashchange', route)
function showList(){
  $('#detailPage').style.display = 'none'; $('#listPage').style.display = 'block'
  if(!state.coins || state.coins.length === 0) loadMarket()
  else renderList(state.coins)
  $('#favCount').textContent = state.favorites.size
}
function route(){
  const h = location.hash.replace('#','') || '/'
  if(h.startsWith('/coin/')){
    const id = h.split('/')[2]
    showDetail(id)
  } else {
    showList()
  }
}

/* -------- DETAIL PAGE & CHART -------- */
let chart = null, candleSeries = null, smaSeries = null, emaSeries = null

async function showDetail(id){
  try{
    $('#listPage').style.display='none'; $('#detailPage').style.display='block'
    $('#coinTitle').textContent = 'Loading‚Ä¶'
    $('#coinDesc').textContent = ''
    $('#coinLinks').textContent = ''
    $('#coinRank').textContent = '‚Äî'
    $('#coinMarketCap').textContent = '‚Äî'
    $('#coinVolume').textContent = '‚Äî'
    $('#coinSupply').textContent = '‚Äî'
    $('#coinPrice').textContent = '‚Äî'

    // fetch asset metadata and 90-day history as default
    state.current = id
    const [meta, hist90] = await Promise.all([
      fetchAsset(id).catch(e=>{ console.warn('meta fail',e); return null }),
      // history: we request daily points for last 365 days, but limit to 90 for chart performance
      (async ()=>{
        const now = Date.now()
        const start = now - (365*24*3600*1000) // 1 year back
        // CoinCap allows interval d1,h1,m1
        return fetchHistory(id, 'd1', start, now).catch(e=>{ console.warn('history fail',e); return [] })
      })()
    ])

    // fill stats from meta if available
    if(meta){
      $('#coinTitle').textContent = `${meta.name} (${meta.symbol})`
      $('#coinRank').textContent = meta.rank ?? '‚Äî'
      $('#coinMarketCap').textContent = meta.marketCapUsd ? fmt(meta.marketCapUsd) : '‚Äî'
      $('#coinVolume').textContent = meta.volumeUsd24Hr ? fmt(meta.volumeUsd24Hr) : '‚Äî'
      $('#coinSupply').textContent = meta.supply ? fmt(meta.supply) : '‚Äî'
      $('#coinPrice').textContent = meta.priceUsd ? Number(meta.priceUsd).toFixed(6) : '‚Äî'
      $('#coinDesc').innerHTML = '<i>Description not available in CoinCap. You can integrate CoinPaprika / CoinGecko for rich descriptions.</i>'
      // CoinCap provides explorer or website? not usually; leave links empty or provide CoinCap page
      $('#coinLinks').innerHTML = `<a href="https://coincap.io/assets/${meta.id}" target="_blank" rel="noopener noreferrer">CoinCap page</a>`
    } else {
      $('#coinTitle').textContent = id
    }

    // Choose range default 30D (button with data-days="30" has 'active' class in markup)
    const defaultDays = 30
    await loadChartRange(id, defaultDays, hist90)

    // watchlist btn
    $('#favBtn').textContent = state.favorites.has(id) ? '‚òÖ In Watchlist' : '‚òÜ Add to Watchlist'
    $('#favBtn').onclick = ()=>{ if(state.favorites.has(id)) state.favorites.delete(id); else state.favorites.add(id); localStorage.setItem('cd:cap:favs', JSON.stringify([...state.favorites])); $('#favBtn').textContent = state.favorites.has(id) ? '‚òÖ In Watchlist' : '‚òÜ Add to Watchlist'; $('#favCount').textContent = state.favorites.size }

    $('#shareBtn').onclick = ()=>{ navigator.share ? navigator.share({title: meta?.name || id, text:'Lihat koin ini', url:location.href}) : prompt('Copy link', location.href) }
  }catch(e){
    console.error(e)
    alert('Gagal muat detail: '+(e.message||e))
    showList()
  }
}

/* Load chart for chosen range (days) ‚Äî tries to fetch appropriate interval from CoinCap and aggregate into OHLC if needed */
async function loadChartRange(id, days, maybeProvidedHistory){
  try{
    // UI: mark active button
    document.querySelectorAll('.rangeBtn').forEach(b=>b.classList.toggle('active', Number(b.dataset.days)===Number(days)))
    // determine interval param for CoinCap: use 'm1' for <=1 day with start/end, 'h1' for <=90days maybe, 'd1' otherwise
    const now = Date.now()
    const start = now - (days * 24 * 3600 * 1000)
    let interval = 'd1'
    if(days <= 1) interval = 'm5' // CoinCap supports m1; but sometimes m5/m1 availability varies. Try m5 (fallback later)
    else if(days <= 90) interval = 'h1'
    else interval = 'd1'

    // try fetch history with determined interval
    let history = []
    try{
      // Some CoinCap deployments are picky about start/end types; ensure integer ms values
      history = await fetchHistory(id, interval, start, now)
      // if not many points or empty, try fallback intervals
      if(!history || history.length < 3){
        if(interval !== 'h1') history = await fetchHistory(id, 'h1', start, now)
        if(!history || history.length < 3) history = await fetchHistory(id, 'd1', start, now)
      }
    }catch(e){
      console.warn('history initial fetch failed', e)
    }

    // sometimes the caller provided a pre-fetched history (maybe longer). Prefer that if it covers requested range.
    if(Array.isArray(maybeProvidedHistory) && maybeProvidedHistory.length && maybeProvidedHistory.length >= history.length){
      // pick portion nearest to requested days
      history = maybeProvidedHistory.filter(pt => Number(pt.time) >= start)
    }

    // history items: {price, time}
    if(!history || history.length === 0){
      // no history -> show message
      const tgt = document.getElementById('tvchart')
      tgt.innerHTML = '<div class="empty">No historical price available for this range.</div>'
      return
    }

    // Convert history price points into OHLC candles: group into buckets depending on desired granularity
    // If history already daily (each point is one day) we can transform to candle where open/high/low/close equal price (best-effort)
    const candleBuckets = convertHistoryToOHLC(history, days)
    // store raw for indicators
    state.lastChartRaw = candleBuckets.map(c => ({ time: Math.floor(c[0]/1000), open:c[1], high:c[2], low:c[3], close:c[4] }))

    // render chart with lightweight-charts
    renderCandles(state.lastChartRaw)
    // compute default indicators if toggled
    if($('#smaToggle').checked) applySMA(state.lastChartRaw, 14)
    if($('#emaToggle').checked) applyEMA(state.lastChartRaw, 14)
  }catch(e){
    console.error('loadChartRange fail', e)
    const tgt = document.getElementById('tvchart')
    tgt.innerHTML = `<div class="empty">Error loading chart: ${e.message}</div>`
  }
}

/* Convert CoinCap history (price points) into OHLC candle array:
   Input: history = [{price: "...", time: 163...}, ...]
   Output: [[tsMillis, open, high, low, close], ...]
   Strategy: choose bucket size based on days requested: for small days aggregate shorter buckets; else daily.
*/
function convertHistoryToOHLC(history, days){
  // ensure numeric time and price
  const pts = history.map(p => ({ t: Number(p.time), v: Number(p.price) || Number(p.priceUsd) || Number(p.priceUsd) } )).filter(p=>p.t && !isNaN(p.v))
  if(pts.length === 0) return []

  // Determine bucket size heuristically:
  // If history points are already spaced >= 24h, treat as daily
  const diffs = []
  for(let i=1;i<pts.length;i++) diffs.push(pts[i].t - pts[i-1].t)
  const avgDiff = diffs.length ? diffs.reduce((a,b)=>a+b,0)/diffs.length : 24*3600*1000
  let bucket = 24*3600*1000
  if(avgDiff <= 60*60*1000) bucket = 60*60*1000 // hourly data -> keep hourly
  else if(avgDiff <= 6*60*60*1000) bucket = 3*60*60*1000
  else bucket = 24*3600*1000

  // For very small range like 1D, create buckets of 5min if possible
  if(days <= 1 && pts.length > 120) bucket = 5*60*1000

  const buckets = {}
  pts.forEach(p=>{
    const b = Math.floor(p.t / bucket) * bucket
    if(!buckets[b]) buckets[b] = []
    buckets[b].push(p.v)
  })
  const keys = Object.keys(buckets).map(k=>Number(k)).sort((a,b)=>a-b)
  const candles = keys.map(k=>{
    const arr = buckets[k]
    return [k, arr[0], Math.max(...arr), Math.min(...arr), arr[arr.length-1]]
  })
  return candles
}

/* RENDER CHART (Lightweight Charts candlestick) */
function renderCandles(candleData){
  const target = document.getElementById('tvchart')
  target.innerHTML = ''
  if(chart) chart.remove()
  chart = LightweightCharts.createChart(target, {
    layout:{background:{color:'transparent'},textColor:'#cfd8e3'},
    grid:{vertLines:{color:'#19303f'},horzLines:{color:'#19303f'}},
    rightPriceScale:{borderColor:'#2b5878'},
    timeScale:{borderVisible:true, borderColor:'#2b5878'}
  })
  candleSeries = chart.addCandlestickSeries()
  candleSeries.setData(candleData)
  // update priceNow
  const last = candleData[candleData.length-1]
  if(last) $('#priceNow').textContent = (Number(last.close)).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:8})
}

/* INDICATORS: SMA & EMA */
let smaApplied = false, emaApplied = false
function applySMA(data, period=14){
  if(!chart || !data || data.length < period) return
  if(smaSeries) smaSeries.remove()
  const closes = data.map(d=>d.close)
  const sma = simpleMA(closes, period)
  const smaData = sma.map((v,i)=>({ time: data[i+period-1].time, value: v })).filter(Boolean)
  smaSeries = chart.addLineSeries({ color: '#ffcc00', lineWidth: 1.4 })
  smaSeries.setData(smaData)
  smaApplied = true
}
function applyEMA(data, period=14){
  if(!chart || !data || data.length < period) return
  if(emaSeries) emaSeries.remove()
  const closes = data.map(d=>d.close)
  const ema = expMA(closes, period)
  const emaData = ema.map((v,i)=>({ time: data[i+period-1].time, value: v })).filter(Boolean)
  emaSeries = chart.addLineSeries({ color: '#00a3ff', lineWidth: 1.3 })
  emaSeries.setData(emaData)
  emaApplied = true
}
function removeSMA(){ if(smaSeries){ smaSeries.remove(); smaSeries = null; smaApplied = false } }
function removeEMA(){ if(emaSeries){ emaSeries.remove(); emaSeries = null; emaApplied = false } }

function simpleMA(arr, period){
  const out = []
  for(let i=0;i<=arr.length-period;i++){
    const slice = arr.slice(i, i+period)
    const s = slice.reduce((a,b)=>a+b,0)/period
    out.push(s)
  }
  return out
}
function expMA(arr, period){
  const k = 2/(period+1)
  const out = []
  let prev = arr.slice(0,period).reduce((a,b)=>a+b,0)/period
  for(let i=period;i<arr.length;i++){
    const v = arr[i]*k + prev*(1-k)
    out.push(v)
    prev = v
  }
  return out
}

/* -------- UI INTERACTIONS -------- */
$('#backBtn').onclick = ()=>{ location.hash = '/' }
$('#themeBtn').onclick = ()=>{ document.documentElement.toggleAttribute('data-theme','light') }
document.querySelectorAll('.rangeBtn').forEach(b => b.onclick = async (e)=>{
  const days = Number(e.target.dataset.days)
  // ask loadChartRange to recalc using days and current id
  if(!state.current) return
  await loadChartRange(state.current, days)
})
$('#smaToggle').onchange = ()=>{ if($('#smaToggle').checked) applySMA(state.lastChartRaw || [], 14); else removeSMA() }
$('#emaToggle').onchange = ()=>{ if($('#emaToggle').checked) applyEMA(state.lastChartRaw || [], 14); else removeEMA() }

/* SEARCH */
$('#search').addEventListener('input', e=>{
  const q = e.target.value.trim().toLowerCase()
  if(!q){ renderList(state.coins); return }
  const filtered = state.coins.filter(c => c.name.toLowerCase().includes(q) || c.symbol.toLowerCase().includes(q) || c.id.toLowerCase().includes(q))
  renderList(filtered)
})

/* SHARE fallback */
$('#shareBtn').onclick = ()=>{ navigator.share ? navigator.share({title: document.title, text:'Check coin', url:location.href}) : prompt('Copy link', location.href) }

/* -------- START -------- */
loadMarket().then(()=>{ route(); $('#favCount').textContent = state.favorites.size })
</script>
</body>
</html>
